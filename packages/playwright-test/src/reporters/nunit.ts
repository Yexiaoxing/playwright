/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FullConfig, FullResult, Reporter, Suite, TestCase } from '../../types/testReporter';
import { cdata, formatFailure, formatTestTitle, serializeXML, stripAnsiEscapes, XMLEntry } from './base';

import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs';

type TestResult = 'Passed' | 'Failed' | 'Inconclusive' | 'Skipped';
type RunState = 'NotRunnable' | 'Runnable' | 'Explicit' | 'Skipped' | 'Ignored';

// In XML, time is HH:MM:SS
interface NunitTestRun extends XMLEntry {
  name: 'test-run',
  attributes: NunitTestRunAttrs,
  children: Array<NunitTestSuite | NunitFilter>
}

interface NunitTestRunAttrs {
  id: string; // The unique ID of this test.
  testcasecount: number;// The number of test cases contained in this test run.
  result: TestResult; // The basic result of the test. May be Passed, Failed, Inconclusive or Skipped.
  total: number; // The total number of test cases executed in the run.This may be less than the testcasecount due to filtering of tests.
  passed: number; // The number of test cases that passed.
  failed: number; // The number of test cases that failed.
  skipped: number; // The number of test cases that were skipped.
  'start-time': string; // - time The UTC time that the test run started.
  'end-time': string; // - time The UTC time that the test run ended.
  duration: number; // The duration of the test run in seconds, expressed as a real number.
}

interface NunitFilter extends XMLEntry {
  name: 'filter',
  children: Array<XMLEntry>
}

interface NunitTestSuite extends XMLEntry {
  name: 'test-suite',
  attributes: NunitTestSuiteAttrs,
  children: Array<NunitTestCase | NunitTestSuite | NunitEnvironment>
}

interface NunitTestSuiteAttrs {
  duration: number; // The duration of the suite in seconds, expressed as a real number.
  failed: number; // The number of test cases that failed.
  fullname: string; // The full name of the test as generated by NUnit.
  id: string; // The unique id of this test. Coded as "mmm-nnn" where the part before the hyphen represents the assembly and the part after it represents a test in that assembly. Currently, mmm and nnn are ints, but that is merely an accident of the implementation and should not be relied on.
  name: string; // The display name of the test as generated by NUnit.
  passed: number; // The number of test cases that passed.
  result: TestResult; // The basic result of the test. May be Passed, Failed, Inconclusive or Skipped.
  runstate: RunState; // An indicator of whether the suite is runnable. Value may be NotRunnable, Runnable, Explicit, Skipped or Ignored. NotRunnable means there is an error in how the test is expressed in code, for example, the signature may be wrong. Explicit, Skipped and Ignored are set by attributes on the test.
  skipped: number; // The number of test cases that were skipped.
  testcasecount: number; // The number of test cases contained, directly or indirectly, in this suite.
  total: number; // The total number of test cases executed under this suite.
  type: 'Assembly' | 'TestFixture'; // The type of suite represented by this element.
}

interface NunitTestCase extends XMLEntry {
  name: 'test-case',
  attributes: NunitTestCaseAttrs,
  children: Array<XMLEntry>
}

interface NunitTestCaseAttrs {
  id: string; // The unique id of this test. Coded as "mmm-nnn" where the part before the hyphen represents the assembly and the part after it represents a test in that assembly. Currently, mmm and nnn are ints, but that is merely an accident of the implementation and should not be relied on.
  name: string; // The display name of the test as generated by NUnit or, in the case of some parameterized tests, specified by the user.
  fullname: string; // The full name of the test as generated by NUnit.
  runstate: RunState; // An indicator of whether the suite is runnable. Value may be NotRunnable, Runnable, Explicit, Skipped or Ignored. NotRunnable means there is an error in how the test is expressed in code, for example, the signature may be wrong. Explicit, Skipped and Ignored are set by attributes on the test.
  result: string; // The basic result of the test. May be Passed, Failed, Inconclusive or Skipped.
  duration: number; // The duration of the test in seconds, expressed as a real number.
}

interface NunitEnvironment extends XMLEntry {
  name: 'environment',
  attributes: NunitEnvironmentAttrs,
}

interface NunitEnvironmentAttrs {
  framework: string; // -version The version of the nunit framework in use.
  'clr-version': string; // The runtime version under which the tests are running, taken from Environment.Version.
  'os-version': string; // A text string describing the operating system running the tests, taken from Environment.OsVersion.
  platform: string; // The platform id, taken from Environment.OsVersion.Platform.
  cwd: string; // The current working directory path, taken from Environment.CurrentDirectory.
  'machine-name': string; // The machine name, taken from Environment.MachineName.
  user: string; // The user id, taken from Environment.UserName.
  'user-domain': string; // The user domain, taken from Environment.UserDomainName.
  culture: string; // The current culture, taken from CultureInfo.CurrentCulture.
  uiculture: string; // The current UI culture, taken from CultureInfo.CurrentUICulture.
  'os-architecture': string; // The architecture, taken from GetProcessorArchitecture().
}

class NunitReporter implements Reporter {
  private _config!: FullConfig;
  private _suite!: Suite;
  private _stripANSIControlSequences = false;
  private _useAbsolutePathForAttachments = false;

  private _outputFile: string | undefined;
  private _startTime: Date = new Date();
  private _startTimeString: string = '';

  private _suiteIndex: number = 0;
  private _testCaseIndex: number = 0;

  constructor(options: { outputFile?: string, stripANSIControlSequences?: boolean, useAbsolutePathForAttachments?: boolean } = {}) {
    this._outputFile = options.outputFile || process.env[`PLAYWRIGHT_NUNIT_OUTPUT_NAME`];
    this._stripANSIControlSequences = options.stripANSIControlSequences || false;
    this._useAbsolutePathForAttachments = options.useAbsolutePathForAttachments || false;
  }

  printsToStdio() {
    return !this._outputFile;
  }

  onBegin(config: FullConfig, suite: Suite) {
    this._config = config;
    this._suite = suite;
    this._startTime = new Date();
    this._startTimeString = getTimeString(this._startTime);
  }

  async onEnd(result: FullResult) {
    outputReport(this._buildReport(result), this._outputFile, this._stripANSIControlSequences);
  }

  private _buildReport(result: FullResult) {
    const children: Array<NunitTestSuite | NunitFilter> = [];

    // #region Test Filters
    const filterChildren: XMLEntry[] = [];

    if (this._config.grep) {
      filterChildren.push({
        name: 'test',
        attributes: {
          re: 1
        },
        text: cdata(this._config.grep.toString()),
      });
    }

    if (this._config.grepInvert) {
      filterChildren.push({
        name: 'not',
        children: [{
          name: 'test',
          attributes: {
            re: 1
          },
          text: cdata(this._config.grepInvert.toString()),
        }]
      });
    }

    if (filterChildren.length > 0) {
      children.push({
        name: 'filter',
        children: filterChildren
      } as NunitFilter);
    }
    // #endregion

    // Get root suite entry
    const { totalTests, totalSkipped, totalFailures, totalDuration, entry } = this._buildTestSuite(this._suite, true);
    children.push(entry);

    const testRunAttrs: NunitTestRunAttrs = {
      'id': process.env[`PLAYWRIGHT_NUNIT_SUITE_ID`] || '',
      'testcasecount': totalTests,
      'result': getTestSuiteResult(result),
      'total': totalTests,
      'passed': totalTests - totalSkipped - totalFailures,
      'failed': totalFailures,
      'skipped': totalSkipped,
      'start-time': this._startTimeString,
      'end-time': getTimeString(new Date(this._startTime.getTime() + totalDuration * 1000)),
      'duration': totalDuration,
    };

    const rootNode: NunitTestRun = {
      name: 'test-run',
      children,
      attributes: testRunAttrs
    };

    return rootNode;
  }

  private _buildTestEnvironment(): NunitEnvironment {
    const attrs: NunitEnvironmentAttrs = {
      'clr-version': 'na',
      'framework': '3.0',
      'machine-name': os.hostname(),
      'os-version': os.release(),
      'user-domain': 'na',
      'culture': getLocalCulture(),
      'os-architecture': os.arch(),
      'uiculture': 'na',
      'cwd': process.cwd(),
      'platform': os.platform(),
      'user': 'na',
    };

    return {
      name: 'environment',
      attributes: attrs
    };
  }

  private _buildTestSuite(suite: Suite, isRoot: boolean = false) {
    const thisSuiteIndex = this._suiteIndex;
    this._suiteIndex += 1;

    let tests = 0;
    let skipped = 0;
    let failures = 0;
    let duration = 0;

    let totalTests = 0;
    let totalSkipped = 0;
    let totalFailures = 0;
    let totalDuration = 0;

    const children: NunitTestSuite['children'] = [];

    if (isRoot)
      children.push(this._buildTestEnvironment());

    let startTime: Date = new Date();

    suite.allTests().forEach(test => {
      // find smallest start time among all tests
      const testStartTime = test.results.reduce((
        acc, curr
      ) => (acc > curr.startTime ? curr.startTime : acc), new Date());

      if (startTime > testStartTime)
        startTime = testStartTime;
    });

    suite.tests.forEach(test => {
      ++tests;
      if (test.outcome() === 'skipped')
        ++skipped;

      if (!test.ok())
        ++failures;

      for (const result of test.results)
        duration += result.duration / 1000;

      children.push(this._buildTestCase(test));
    });

    totalTests += tests;
    totalSkipped += skipped;
    totalFailures += failures;
    totalDuration += duration;

    suite.suites.forEach(subsuite => {
      const {
        totalTests: suiteTests,
        totalSkipped: sutieSkipped,
        totalFailures: suiteFailures,
        totalDuration: suiteDuration,
        entry
      } = this._buildTestSuite(subsuite);

      totalTests += suiteTests;
      totalSkipped += sutieSkipped;
      totalFailures += suiteFailures;
      totalDuration += suiteDuration;

      children.push(entry);
    });

    // TODO: correct name?
    const fullname = suite.location ? path.relative(this._config.rootDir, suite.location.file) : '';

    const entry: NunitTestSuite = {
      name: 'test-suite',
      attributes: {
        type: isRoot ? 'Assembly' : 'TestFixture', // The type of suite represented by this element.
        id: thisSuiteIndex.toString(), // The unique id of this test. Coded as "mmm-nnn" where the part before the hyphen represents the assembly and the part after it represents a test in that assembly. Currently, mmm and nnn are ints, but that is merely an accident of the implementation and should not be relied on.
        name: suite.title, // The display name of the test as generated by NUnit.
        fullname: fullname, // The full name of the test as generated by NUnit.
        testcasecount: suite.allTests().length, // The number of test cases contained, directly or indirectly, in this suite.
        runstate: 'Runnable', // An indicator of whether the suite is runnable. Value may be NotRunnable, Runnable, Explicit, Skipped or Ignored. NotRunnable means there is an error in how the test is expressed in code, for example, the signature may be wrong. Explicit, Skipped and Ignored are set by attributes on the test.
        result: getResult(totalTests, totalSkipped, totalFailures), // The basic result of the test. May be Passed, Failed, Inconclusive or Skipped.
        duration: duration, // The duration of the suite in seconds, expressed as a real number.
        total: totalTests, // The total number of test cases executed under this suite.
        passed: totalTests - totalFailures - totalSkipped, // The number of test cases that passed.
        failed: totalFailures, // The number of test cases that failed.
        skipped: totalSkipped, // The number of test cases that were skipped.
      },
      children,
    };

    return {
      totalTests,
      totalSkipped,
      totalFailures,
      totalDuration,
      entry,
    };
  }

  private _buildTestCase(test: TestCase): NunitTestCase {
    const thisCaseIndex = this._testCaseIndex;
    this._testCaseIndex += 1;

    const children: XMLEntry[] = [];

    let duration = 0;
    const systemOut: string[] = [];
    const systemErr: string[] = [];
    const attachments: XMLEntry[] = [];
    for (const result of test.results) {
      duration += result.duration / 1000;
      systemOut.push(...result.stdout.map(item => item.toString()));
      systemErr.push(...result.stderr.map(item => item.toString()));
      for (const attachment of result.attachments) {
        if (!attachment.path || !this._outputFile)
          continue;

        try {
          // TODO: add option for absolute or relative?
          let attachmentPath: string;
          if (this._useAbsolutePathForAttachments)
            attachmentPath  = attachment.path;
          else
            attachmentPath = path.relative(this._config.rootDir, attachment.path);


          if (fs.existsSync(attachment.path)) {
            systemOut.push(`\n[[ATTACHMENT|${attachmentPath}]]\n`);
            attachments.push({
              name: 'attachment',
              children: [
                {
                  name: 'filePath',
                  text: attachmentPath,
                },
                {
                  name: 'description',
                  text: cdata(attachment.name),
                },
              ],
            });
          } else {
            systemErr.push(`\nWarning: attachment ${attachmentPath} is missing`);
          }
        } catch (e) { }
      }
    }

    if (!test.ok())
      systemErr.push(stripAnsiEscapes(formatFailure(this._config, test).message));


    if (systemOut.length) {
      children.push({
        name: 'output',
        text: cdata(systemOut.join('\n'))
      });
    }

    if (systemErr.length) {
      children.push({
        name: 'failure',
        children: [{
          name: 'message',
          text: cdata(systemErr.join('\n'))
        }]
      });
    }

    if (attachments.length) {
      children.push({
        name: 'attachments',
        children: attachments
      });
    }

    const attrs: NunitTestCaseAttrs = {
      id: `${this._suiteIndex}-${thisCaseIndex}`,
      name: test.title,
      fullname: formatTestTitle(this._config, test),
      runstate: test.expectedStatus === 'skipped' ? 'Skipped' : 'Runnable',
      result: getResult(1, test.expectedStatus === 'skipped' ? 1 : 0, test.ok() ? 0 : 1),
      duration,
    };

    return {
      name: 'test-case',
      attributes: attrs,
      children,
    };
  }
}

function outputReport(root: XMLEntry, outputFile: string | undefined, stripANSIControlSequences: boolean) {
  const tokens: string[] = serializeXML(root, stripANSIControlSequences);

  tokens.splice(0,0, '<?xml version="1.0" encoding="utf-8"?>');

  const reportString = tokens.join('\n');

  if (outputFile) {
    fs.mkdirSync(path.dirname(outputFile), { recursive: true });
    fs.writeFileSync(outputFile, reportString);
  } else {
    console.log(reportString);
  }

}

function getTimeString(datetime: Date) {
  const hour = datetime.getUTCHours();
  const minute = datetime.getUTCMinutes();
  const second = datetime.getUTCSeconds();

  const padNumber = (number: number) => {
    return ('0' + number).slice(-2);
  };

  return `${padNumber(hour)}:${padNumber(minute)}:${padNumber(second)}`;
}

function getLocalCulture() {
  const env = process.env;
  const language = env.LANG || env.LANGUAGE || env.LC_ALL || env.LC_MESSAGES;

  if (language) {
    const parts = language.split('.');

    return parts[0];
  }

  return '';
}

function getResult(tests: number, skipped: number, failures: number): TestResult {
  if (skipped === 0 && failures === 0)
    return 'Passed';


  if (tests === skipped)
    return 'Skipped';


  return 'Failed';
}

function getTestSuiteResult(result: FullResult): TestResult {
  switch (result.status) {
    case 'passed':
      return 'Passed';
    default:
      return 'Failed';
  }
}

export default NunitReporter;
